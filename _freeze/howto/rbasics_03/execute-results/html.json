{
  "hash": "7314d943f74ad176d94ca5db22fe6ba5",
  "result": {
    "markdown": "---\ntitle: \"Lesson 3: Tidy Data\"\nsidebar: true\ntoc: true\npage-layout: full\nformat: \n  html:\n    code-link: true\neditor: visual\n---\n\n\n## Lesson Overview\n\nIn our previous two lessons, we've been working with Base R to do basic manipulation of data. These strategies are powerful and can do a lot, however, they are a bit clunky (something you may have been thinking to yourself) - there are tools and strategies that are tailored to the types of data forms and structures we tend to use to measure characteristics and dynamics of neighborhoods.\n\nIn this lesson, we'll introduce principles of *tidy* data as well as a frequently used R package designed to help us manipulate and work more efficiently.\n\n## Lesson Goals\n\nBy the end of this lesson, you should be familiar with:\n\n-   Principles of *tidy* data\n-   High-level tools for selecting and subsetting data using `dplyr` syntax\n-   More advanced strategies for grouping and summarizing data using `dplyr` syntax\n\n## Getting Set Up\n\n### Loading Required Packages\n\nWe're been working primarily in \"base\" R as we are getting familiar with the R language and RStudio interface. In Lesson 2, we introduced packages and made use of the `readxl` package to load data from an Excel file into R.\n\nTo review, we used `install.packages()` and `library()` to (respectively) install and load packages that extend R and RStudio's functionality. If you remember from our last lesson, you will only need to install a package once, but you will need to load it every time you start your R session and want to use it.\n\nLet's start by loading the following packages:\n\n-   `readxl` contains tools which will help us to read Excel files into R\n-   `tidyverse` contains tools which we'll use to subset, filter, group, and summarize our data\n\nIf you completed the last lesson, you will already have installed `readxl`. Let's install the `tidyverse` package and then load both the `readxl` and `tidyverse` packages for use:\n\n::: panel-tabset\n#### Your Turn\n\nTry installing the `tidyverse` package (if it is not already installed on your machine), and then load `readxl` and `tidyverse` for use in your R session.\n\n#### Solution\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.2     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.2     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"tidyverse\")\nlibrary(tidyverse)\nlibrary(readxl)\n```\n:::\n\n:::\n\n### Loading Data\n\nIf it's not already loaded, load the OZ dataset we worked with in Lesson 2. You can assign the data whatever name you'd like, but we will stick with the name we used previously, 'ozs'. A copy of the Urban Institute's dataset is [available here for download](https://uofi.box.com/s/oh2455rlshpioodbmqfgpk5nkfep027n).\n\n::: column-margin\nYou'll need to authenticate and log in to UIUC Box to access this file. You can also download the data [directly](https://www.urban.org/sites/default/files/2021-01/urbaninstitute_tractlevelozanalysis_update01142021.xlsx) from Urban Institute's Opportunity Zone [landing page](https://www.urban.org/policy-centers/metropolitan-housing-and-communities-policy-center/projects/opportunity-zones).\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nozs <- read_excel(\"data/urbaninstitute_tractlevelozanalysis_update01142021.xlsx\")\n```\n:::\n\n\n## An easier and more efficient way?\n\nWe could keep building queries in base R to describe or summarize other variables in our data. Looking at the code you've created in Lesson 2 in particular, you're probably thinking that it looks fairly illegible. Part of the challenge of code like this is that you have to read from the inside out.\n\nLet's learn a *whole different* way of constructing this same thing.\n\n### Principles of Tidy Data\n\nThis lesson focuses on introducing the [`tidyverse`](https://www.tidyverse.org), a series of packages designed specifically to make data science easier in R and RStudio. The functionality of the `tidyverse` is largely described in the accompanying book [R for Data Science](https://r4ds.had.co.nz).\n\nData are structured for tidy analysis when columns each contain one individual *variable*, each row represents a unique *observation*, and there is only one *value* for each variable and observation:\n\n![](images/tidy-1.png)\n\nThe majority of the data which we will encounter in this class, and the majority of data we work with as planners already conforms to these principles.\n\nIn the case of the Opportunity Zone data we first looked at in Lesson 2, here's what that looked like:\n\n-   Each column represented a different *variable*, for instance, whether an observation was designated an Opportunity Zone, the poverty rate, or the median household income.\n\n-   Each row represented a unique *observation*, in this case a unique census tract.\n\n-   Each *value* was unique and there was only one value for every *variable* and *observation*.\n\n::: column-margin\nIf you want to understand some of the rationale behind tidy data, Hadley Wickham's [article](https://vita.had.co.nz/papers/tidy-data.pdf) is a good resource.\n:::\n\n## Your First Tidy Coding\n\nAt this point, you should have your data loaded and available and you should also have the `tidyverse` and `readxl` packages loaded.\n\nIn Lesson 2, you worked on solving the following two data manipulation and description problems:\n\n1.  Report average poverty rates for *designated* opportunity zones in metropolitan, micropolitan, and non-CBSA areas.\n\n2.  For Illinois, how different are the average vacancy rates for *designated* and *undesignated* census tracts?\n\nLet's compare how to do that using base R and using commands from the `tidyverse` suite.\n\n### Poverty Rates\n\n::: panel-tabset\n#### The Problem\n\nReport average poverty rates for *designated* opportunity zones in metropolitan, micropolitan, and non-CBSA areas.\n\n#### Base R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(ozs$PovertyRate[ozs$DesignatedOZ == 1 & ozs$Metro == 1], na.rm=TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.3335197\n```\n:::\n\n```{.r .cell-code}\nmean(ozs$PovertyRate[ozs$DesignatedOZ == 1 & ozs$Micro == 1], na.rm=TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.2803457\n```\n:::\n\n```{.r .cell-code}\nmean(ozs$PovertyRate[ozs$DesignatedOZ == 1 & ozs$NoCBSAType == 1], na.rm=TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.2357986\n```\n:::\n:::\n\n\n#### Tidy\n\n\n::: {.cell}\n\n```{.r .cell-code}\nozs |> \n  filter(DesignatedOZ ==1, Metro == 1) |>\n  summarise(mean(PovertyRate, na.rm=TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n  `mean(PovertyRate, na.rm = TRUE)`\n                              <dbl>\n1                             0.334\n```\n:::\n\n```{.r .cell-code}\nozs |> \n  filter(DesignatedOZ ==1, Micro == 1) |>\n  summarise(mean(PovertyRate, na.rm=TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n  `mean(PovertyRate, na.rm = TRUE)`\n                              <dbl>\n1                             0.280\n```\n:::\n\n```{.r .cell-code}\nozs |> \n  filter(DesignatedOZ ==1, NoCBSAType == 1) |>\n  summarise(mean(PovertyRate, na.rm=TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n  `mean(PovertyRate, na.rm = TRUE)`\n                              <dbl>\n1                             0.236\n```\n:::\n:::\n\n:::\n\nWe get the same values out, but note the code we input in order to get these outputs is very different!\n\nLet's break this down further.\n\nIn Base R...\n\n1.  We first specified the statistic we wanted `mean()`.\n\n2.  We then specified the dataset and columns we wanted that mean for `ozs$PovertyRate`.\n\n3.  We then specified we only wanted a subset of the poverty rate variable where observations were designated opportunity zones and then based upon a metropolitan criterion. `[ozs$DesignatedOZ == 1 & ozs$Metro == 1]`\n\n4.  We also specified that we wanted to remove `NA` values from our calculation of the average `mean(na.rm=TRUE)`.\n\nAs a reminder, when put together, these things looked like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nozs |> \n  filter(DesignatedOZ ==1, Metro == 1) |>\n  summarise(mean(PovertyRate, na.rm=TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n  `mean(PovertyRate, na.rm = TRUE)`\n                              <dbl>\n1                             0.334\n```\n:::\n:::\n\n\nNext, let's look at the structure of the tidy command to do the same thing:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nozs |>                                       # <1>\n  filter(DesignatedOZ ==1, Metro == 1) |>    # <2>\n  summarise(mean(PovertyRate, na.rm=TRUE))   # <3>\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n  `mean(PovertyRate, na.rm = TRUE)`\n                              <dbl>\n1                             0.334\n```\n:::\n:::\n\n\n1.  From the 'ozs' dataset;\n2.  *Filter* (select rows from) the dataset where the DesignatedOZ column is equal to 1 (designated) *AND* the Metropolitan area flag is equal to 1 (a metropolitan area);\n3.  For the filtered data from 'ozs', *summarize* (report back) the mean value for the PovertyRate column, removing NA values.\n\nThis is still complex, but we gain a major benefit - where in our Base R strategy the code is nested and hard to read, the Tidy syntax offers a more logical workflow. We used something called a *pipe* `|>` to *pass* results of previous commands along a data analysis pipeline. This allows us to code steps in a logical order and makes it much easier to read and interpret what we're doing step-by-step.\n\n### Vacancy Rates\n\nLet's now compare code for our second challenge - examining vacancy rates.\n\n::: panel-tabset\n#### The Problem\n\nFor Illinois, how different are the average vacancy rates for *designated* and *undesignated* census tracts?\n\n#### Base R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nozs$DesignatedOZ[is.na(ozs$DesignatedOZ)]<-0\n\nmean(ozs$vacancyrate[ozs$DesignatedOZ == 1], na.rm=TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.1583661\n```\n:::\n\n```{.r .cell-code}\nmean(ozs$vacancyrate[ozs$DesignatedOZ == 0], na.rm=TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.1367463\n```\n:::\n:::\n\n\n#### Tidy\n\n\n::: {.cell}\n\n```{.r .cell-code}\nozs |> # <1>\n  replace_na(list(DesignatedOZ = 0)) |> # <2>\n  group_by(DesignatedOZ) |> # <3>\n  summarise(mean(vacancyrate, na.rm=TRUE)) # <4>\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 2\n  DesignatedOZ `mean(vacancyrate, na.rm = TRUE)`\n         <dbl>                             <dbl>\n1            0                             0.137\n2            1                             0.158\n```\n:::\n:::\n\n\n1.  From the 'ozs' dataset,\n2.  Replace any values that at `NA` in the DesignatedOZ column with the value 0,\n3.  Treat our data as being *grouped* by the unique values of DesignatedOZ,\n4.  Summarize for us the mean value for vacancy rate, removing any NA values from our calculation.\n:::\n\nLots going on, but let's pay attention to some cool things we just saw.\n\n-   As we had with the poverty rate we started with our 'ozs' dataset and then sequentially modified the dataset to get to our final output - a summary output with values for the average vacancy rate for designated and eligible but not designated tracts.\n\n-   We were able to substitute `NA` values with 0 using a special command in line with our data modification workflow.\n\n-   We used something we haven't seen before - `group_by()` to tell R to treat our data as grouped by the values of the DesignatedOZ variable.\n\n-   We used `summarise()` to create an output table containing the average values for the vacancy rate grouped by the values in DesignatedOZ.\n\nThis quick illustration helps you understand some of the basics of how `dplyr` works. Two major improvements, in addition to specific commands for filtering rows and selecting columns are the use of pipes `|>` and the ability to summarize data. You'll also notice that the output is rendered in a minimally formatted table.\n\n## Basic `dplyr` verbs\n\n### Filtering Data\n\nWe can use dplyr to *filter* out rows that meet certain criteria.\n\nFor instance, here's how we're filter out all records for tracts in Illinois:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nozs |>  # <1>\n  filter(state == \"Illinois\") # <2>\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,659 × 27\n   geoid       state    DesignatedOZ county   Type  dec_score SE_Flag Population\n   <chr>       <chr>           <dbl> <chr>    <chr>     <dbl>   <dbl>      <dbl>\n 1 17001000201 Illinois            0 Adams C… Non-…         7      NA       1937\n 2 17001000202 Illinois            0 Adams C… Low-…         1      NA       2563\n 3 17001000400 Illinois            0 Adams C… Low-…         1      NA       3403\n 4 17001000500 Illinois            0 Adams C… Low-…         1      NA       2298\n 5 17001000700 Illinois            0 Adams C… Low-…         1      NA       1259\n 6 17001000800 Illinois            1 Adams C… Low-…         1      NA       2700\n 7 17001000900 Illinois            0 Adams C… Low-…         5      NA       2671\n 8 17001010100 Illinois            0 Adams C… Non-…         2      NA       4323\n 9 17001010200 Illinois            0 Adams C… Low-…         2      NA       3436\n10 17001010300 Illinois            0 Adams C… Non-…         8      NA       6038\n# ℹ 1,649 more rows\n# ℹ 19 more variables: medhhincome <dbl>, PovertyRate <dbl>, unemprate <dbl>,\n#   medvalue <dbl>, medrent <dbl>, pctown <dbl>, severerentburden <dbl>,\n#   vacancyrate <dbl>, pctwhite <dbl>, pctBlack <dbl>, pctHispanic <dbl>,\n#   pctAAPIalone <dbl>, pctunder18 <dbl>, pctover64 <dbl>, HSorlower <dbl>,\n#   BAorhigher <dbl>, Metro <dbl>, Micro <dbl>, NoCBSAType <dbl>\n```\n:::\n:::\n\n\n1.  From the ozs data object;\n2.  Filter out those rows in the column \"state\" for which state is equal to \"Illinois\"\n\n### Selecting Columns\n\nSimilar to filter, we can use `select()` to select specific columns in our data frame:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nozs |> # <1>\n  select(state, DesignatedOZ) # <2>\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 42,178 × 2\n   state   DesignatedOZ\n   <chr>          <dbl>\n 1 Alabama            0\n 2 Alabama            0\n 3 Alabama            1\n 4 Alabama            0\n 5 Alabama            0\n 6 Alabama            0\n 7 Alabama            0\n 8 Alabama            1\n 9 Alabama            0\n10 Alabama            1\n# ℹ 42,168 more rows\n```\n:::\n:::\n\n\n1.  From the ozs dataset;\n2.  Select the columns named \"state\" and \"DesignatedOZ\".\n\n### Combining `filter()` and `select()`\n\nYour turn - create a table containing the variables state, Designated, and Metro, for Illinois:\n\n::: panel-tabset\n#### Your Turn\n\nFor Illinois, create a table containing the variables state, Designated, and Metro.\n\n#### Solution\n\n\n::: {.cell}\n\n```{.r .cell-code}\nozs |> # <1>\n  select(state, DesignatedOZ, Metro) |> # <2>\n  filter(state == \"Illinois\") # <3>\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,659 × 3\n   state    DesignatedOZ Metro\n   <chr>           <dbl> <dbl>\n 1 Illinois            0    NA\n 2 Illinois            0    NA\n 3 Illinois            0    NA\n 4 Illinois            0    NA\n 5 Illinois            0    NA\n 6 Illinois            1    NA\n 7 Illinois            0    NA\n 8 Illinois            0    NA\n 9 Illinois            0    NA\n10 Illinois            0    NA\n# ℹ 1,649 more rows\n```\n:::\n:::\n\n\n1.  From the 'ozs' dataset;\n2.  Select the columns \"state\", \"Designated OZ\", and \"Metro\";\n3.  From the state column, select the subset of values where state is equal to \"Illinois\".\n:::\n\nYou should return a data frame with three columns and 1,659 rows.\n\n::: panel-tabset\n#### Your Turn\n\nHow would you modify your code to limit this to tracts that were Metropolitan (Metro equal to 1)?\n\n#### Solution\n\n\n::: {.cell}\n\n```{.r .cell-code}\nozs |> # <1>\n  select(state, DesignatedOZ, Metro) |> # <2>\n  filter(state == \"Illinois\", Metro == 1) # <3>\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,344 × 3\n   state    DesignatedOZ Metro\n   <chr>           <dbl> <dbl>\n 1 Illinois            0     1\n 2 Illinois            0     1\n 3 Illinois            0     1\n 4 Illinois            1     1\n 5 Illinois            1     1\n 6 Illinois            0     1\n 7 Illinois            1     1\n 8 Illinois            0     1\n 9 Illinois            0     1\n10 Illinois            0     1\n# ℹ 1,334 more rows\n```\n:::\n:::\n\n\n1.  From the 'ozs' dataset;\n2.  Select the columns \"state\", \"Designated OZ\", and \"Metro\";\n3.  From the state column, select the subset of values where state is equal to \"Illinois\" AND where the Metro column is equal to 1.\n:::\n\nIf you do this successfully, you should end up with 1,344 observations.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nozs |>\n  select(state, DesignatedOZ, Metro) |>\n  filter(state == \"Illinois\", Metro == 1) |> \n  nrow()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1344\n```\n:::\n:::\n\n\n### Group By and Summarise\n\nIn the vacancy rate illustration that we saw above, we were able to *group* our data by a particular categorical variable and then *summarize* based upon another variable, in that case then average vacancy rate.\n\nLet's see what that looks like again, this time, finding the average median household income for designated and not designated but eligible opportunity zone tracts:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nozs |> \n  group_by(DesignatedOZ) |>  summarise(mean(medhhincome, na.rm=TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 2\n  DesignatedOZ `mean(medhhincome, na.rm = TRUE)`\n         <dbl>                             <dbl>\n1            0                            44446.\n2            1                            33346.\n```\n:::\n:::\n\n\nA little tip here - we can easily change the name of the column label for our summarized values as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nozs |> \n  group_by(DesignatedOZ) |>  summarise(income = mean(medhhincome, na.rm=TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 2\n  DesignatedOZ income\n         <dbl>  <dbl>\n1            0 44446.\n2            1 33346.\n```\n:::\n:::\n\n\nWithin our `summarise()` code, we can create multiple columns with each separated by a comma.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nozs |> \n  group_by(DesignatedOZ) |>  summarise(\n    tracts = n(),\n    income = mean(medhhincome, na.rm=TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 3\n  DesignatedOZ tracts income\n         <dbl>  <int>  <dbl>\n1            0  33414 44446.\n2            1   8764 33346.\n```\n:::\n:::\n\n\n`n()` returns the count of the number of records within each group.\n\n::: panel-tabset\n#### Your Turn\n\nYour turn - add to our above summary table the average poverty rate (PovertyRate) and the average proportion of the population facing severe rent burden (severerentburden). You can name them whatever you want\n\n#### Solution\n\n\n::: {.cell}\n\n```{.r .cell-code}\nozs |> \n  group_by(DesignatedOZ) |>  summarise(\n    tracts = n(),\n    income = mean(medhhincome, na.rm=TRUE),\n    poverty = mean(PovertyRate, na.rm=TRUE),\n    rent_burden = mean(severerentburden, na.rm=TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 5\n  DesignatedOZ tracts income poverty rent_burden\n         <dbl>  <int>  <dbl>   <dbl>       <dbl>\n1            0  33414 44446.   0.211       0.243\n2            1   8764 33346.   0.317       0.265\n```\n:::\n:::\n\n:::\n\nIt looks like designated opportunity zones have lower incomes, higher poverty rates, and higher levels of severe rent burden.\n\nThis is a big step up from what we were doing earlier. We know how different designated and undesignated tracts are throughout the US, but how different are they for each state in the US?\n\nHow would we go about modifying our code to create this grouping?\n\n::: panel-tabset\n#### Your Turn\n\nModify your above code to group your data by state and designation status in order to be able to examine state-to-state differences.\n\n#### Solution\n\n\n::: {.cell}\n\n```{.r .cell-code}\nozs |> \n  group_by(state, DesignatedOZ) |>  summarise(\n    tracts = n(),\n    income = mean(medhhincome, na.rm=TRUE),\n    poverty = mean(PovertyRate, na.rm=TRUE),\n    rent_burden = mean(severerentburden, na.rm=TRUE))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'state'. You can override using the\n`.groups` argument.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 108 × 6\n# Groups:   state [57]\n   state          DesignatedOZ tracts income poverty rent_burden\n   <chr>                 <dbl>  <int>  <dbl>   <dbl>       <dbl>\n 1 Alabama                   0    677 36542.   0.239       0.212\n 2 Alabama                   1    158 30044.   0.328       0.246\n 3 Alaska                    0     43 54784.   0.149       0.180\n 4 Alaska                    1     25 49840.   0.167       0.178\n 5 American Samoa            1     16   NaN  NaN         NaN    \n 6 Arizona                   0    702 40961.   0.246       0.236\n 7 Arizona                   1    168 34373.   0.315       0.237\n 8 Arkansas                  0    435 37814.   0.221       0.192\n 9 Arkansas                  1     85 31254.   0.301       0.228\n10 California                0   3464 50858.   0.207       0.298\n# ℹ 98 more rows\n```\n:::\n:::\n\n:::\n\nIf you modified this correctly, you should now have an output table with 108 rows, each reflecting summaries for a state and unique OZ designation status.\n\nThere are other fairly interesting things that we can do with our grouping and summarizing. We figured out how to use multiple groups to summarize our data in useful ways. What we probably want is to get that all into the same table.\n\nOne strategy for doing this is to include conditions in our summary statements. The code below summarizes the average median income by state, but then includes conditions on summarizing means income. This allows us to get the incomes of designated and undesignated tracts on the same row.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nozs |>  \n  group_by(state) |> \n  summarise(\n    tracts = n(), \n    income = mean(medhhincome, na.rm=TRUE), \n    Des_inc = mean(medhhincome[DesignatedOZ == 1], na.rm=TRUE), \n    Not_Des_Inc = mean(medhhincome[DesignatedOZ == 0], na.rm=TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 57 × 5\n   state                tracts income Des_inc Not_Des_Inc\n   <chr>                 <int>  <dbl>   <dbl>       <dbl>\n 1 Alabama                 835 35311.  30044.      36542.\n 2 Alaska                   68 52911.  49840.      54784.\n 3 American Samoa           16   NaN     NaN         NaN \n 4 Arizona                 870 39692.  34373.      40961.\n 5 Arkansas                520 36740.  31254.      37814.\n 6 California             4343 47878.  36134.      50858.\n 7 Colorado                657 47976.  41138.      49601.\n 8 Connecticut             344 48318.  36760.      51389.\n 9 Delaware                118 48200.  40971.      50143.\n10 District of Columbia    116 57672.  38291.      62840.\n# ℹ 47 more rows\n```\n:::\n:::\n\n\n::: panel-tabset\n#### Your Turn\n\nHow would you modify the above code to produce the same table for *counties* in *Illinois*?\n\n#### Solution\n\n\n::: {.cell}\n\n```{.r .cell-code}\nozs |>  \n  filter(state == \"Illinois\") |> \n  group_by(county) |> \n  summarise(\n    tracts = n(), \n    income = mean(medhhincome, na.rm=TRUE), \n    Des_inc = mean(medhhincome[DesignatedOZ == 1], na.rm=TRUE), \n    Not_Des_Inc = mean(medhhincome[DesignatedOZ == 0], na.rm=TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 95 × 5\n   county           tracts income Des_inc Not_Des_Inc\n   <chr>             <int>  <dbl>   <dbl>       <dbl>\n 1 Adams County         10 38254   26012       39614.\n 2 Alexander County      4 29982.  21500       32809 \n 3 Bond County           2 50950   49590       52310 \n 4 Boone County          3 44028.  40599       45742 \n 5 Bureau County         4 57275.  48083       60339.\n 6 Calhoun County        2 55290     NaN       55290 \n 7 Carroll County        2 47063   35184       58942 \n 8 Cass County           3 43787.  37679       46840.\n 9 Champaign County     30 39063.  13989.      45604.\n10 Christian County      8 44723.  36164       45945.\n# ℹ 85 more rows\n```\n:::\n:::\n\n:::\n\n### Mutate\n\nWe're getting pretty good at passing data along using pipes (`|>`). We've learned how to use `group_by()` and `summarise()` to quickly create summary tables. What if we wanted to modify these tables? One thing that might help us better understand our summary table would be to calculate the difference in the average median income for our designated and not designated tracts.\n\n`mutate()` allows us to add new columns to our existing data (this will work on non-summarized data too). The code below adds a column called \"Inc_Diff\" to our summary table, and places into this column the difference between the income in designated and not designated census tracts:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nozs |>  \n  filter(state == \"Illinois\") |>  \n  group_by(county) |>  \n  summarise(\n    tracts = n(), \n    income = mean(medhhincome, na.rm=TRUE), \n    Des_inc = mean(medhhincome[DesignatedOZ == 1], na.rm=TRUE), \n    Not_Des_Inc = mean(medhhincome[DesignatedOZ == 0], na.rm=TRUE)) |> \n  mutate(Inc_Diff = Des_inc - Not_Des_Inc)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 95 × 6\n   county           tracts income Des_inc Not_Des_Inc Inc_Diff\n   <chr>             <int>  <dbl>   <dbl>       <dbl>    <dbl>\n 1 Adams County         10 38254   26012       39614.  -13602.\n 2 Alexander County      4 29982.  21500       32809   -11309 \n 3 Bond County           2 50950   49590       52310    -2720 \n 4 Boone County          3 44028.  40599       45742    -5143 \n 5 Bureau County         4 57275.  48083       60339.  -12256.\n 6 Calhoun County        2 55290     NaN       55290      NaN \n 7 Carroll County        2 47063   35184       58942   -23758 \n 8 Cass County           3 43787.  37679       46840.   -9162.\n 9 Champaign County     30 39063.  13989.      45604.  -31615.\n10 Christian County      8 44723.  36164       45945.   -9781.\n# ℹ 85 more rows\n```\n:::\n:::\n\n\nNotice that we needed to add another pipe here so that we were mutating our summary table and not our original data. Notice that most designated tracts have much lower median household incomes when compared to eligible but not designated places - that would suggest that the program is targeting neighborhoods with greater need.\n\n## Time for Practice!\n\nLet's spend a little time practicing filtering, grouping, and summarizing data using dplyr commands.\n\n::: panel-tabset\n#### Your Turn\n\nCreate a summary table of the racial characteristics of designated and not designated tracts at the nation level.\n\nRacial characteristics are pctwhitw, pctBlack, pctHispanic, pctAAPIalone.\n\n#### Solution\n\n\n::: {.cell}\n\n```{.r .cell-code}\nozs |> \n  group_by(DesignatedOZ) |> \n  summarise(\n    White = mean(pctwhite, na.rm=TRUE), \n    Black = mean(pctBlack, na.rm=TRUE), \n    Hispanic = mean(pctHispanic, na.rm=TRUE), \n    AAPI = mean(pctAAPIalone, na.rm=TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 5\n  DesignatedOZ White Black Hispanic   AAPI\n         <dbl> <dbl> <dbl>    <dbl>  <dbl>\n1            0 0.554 0.172    0.200 0.0404\n2            1 0.396 0.240    0.299 0.0292\n```\n:::\n:::\n\n:::\n\n::: panel-tabset\n#### Your Turn\n\nLooking at the state level (by each state), how different are the poverty rates of *designated* opportunity zones in metropolitan, micropolitan, and non-CBSA areas?\n\n#### Solution\n\n\n::: {.cell}\n\n```{.r .cell-code}\nozs |> \n  filter(DesignatedOZ == 1) |> \n  group_by(state) |>  \n  summarise(\n    Metro = mean(PovertyRate[Metro == 1], na.rm=TRUE),\n    Micro = mean(PovertyRate[Micro == 1], na.rm=TRUE),\n    Non_CBSA = mean(PovertyRate[NoCBSAType == 1], na.rm=TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 56 × 4\n   state                  Metro   Micro Non_CBSA\n   <chr>                  <dbl>   <dbl>    <dbl>\n 1 Alabama                0.347   0.282    0.275\n 2 Alaska                 0.156 NaN        0.178\n 3 American Samoa       NaN     NaN      NaN    \n 4 Arizona                0.319   0.311    0.239\n 5 Arkansas               0.334   0.287    0.262\n 6 California             0.332   0.311    0.209\n 7 Colorado               0.245   0.169    0.201\n 8 Connecticut            0.284   0.319  NaN    \n 9 Delaware               0.262 NaN      NaN    \n10 District of Columbia   0.322 NaN      NaN    \n# ℹ 46 more rows\n```\n:::\n:::\n\n:::\n\n::: panel-tabset\n#### Your Turn\n\nLooking at the state level (by state), what's the average age dependence ratio for designated and non-designated tracts?\n\nTip: The age dependence ratio is the proportion of the population under 18 or over 64 compared to the population between 18 and 64. In our dataset, we have the proportion under 18 (pctunder18) and the proportion over 64 (pctover64)\n\n#### Solution\n\n\n::: {.cell}\n\n```{.r .cell-code}\nozs |>  \n  select(state, DesignatedOZ, pctunder18, pctover64) |>  \n  mutate(\n    adr = (pctunder18+pctover64)/(1-(pctunder18+pctover64))) |> \n  group_by(state) |>   \n  summarise(Designated_ADR = mean(adr[DesignatedOZ == 1], na.rm=TRUE),\n          NotDesignated_ADR = mean(adr[DesignatedOZ == 0], na.rm=TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 57 × 3\n   state                Designated_ADR NotDesignated_ADR\n   <chr>                         <dbl>             <dbl>\n 1 Alabama                       0.592             0.644\n 2 Alaska                        0.540             0.556\n 3 American Samoa              NaN               NaN    \n 4 Arizona                       0.651             0.771\n 5 Arkansas                      0.643             0.681\n 6 California                    0.606             0.590\n 7 Colorado                      0.590             0.572\n 8 Connecticut                   0.543             0.560\n 9 Delaware                      0.601             0.614\n10 District of Columbia          0.535             0.486\n# ℹ 47 more rows\n```\n:::\n:::\n\n:::\n\n::: panel-tabset\n#### Your Turn\n\nLooking the state of Illinois, whats the average poverty and income for tracts based upon their level of investment flows (the dec_score variable)? \\#### Solution\n\n\n::: {.cell}\n\n```{.r .cell-code}\nozs |>  \n  filter(state == \"Illinois\") |> \n  group_by(dec_score) |>   \n  summarise(Count = n(),\n            Poverty = mean(PovertyRate, na.rm=TRUE),\n            Income = mean(medhhincome, na.rm=TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 11 × 4\n   dec_score Count Poverty Income\n       <dbl> <int>   <dbl>  <dbl>\n 1         1   165   0.199 41642.\n 2         2   165   0.227 40782.\n 3         3   165   0.278 36666.\n 4         4   164   0.277 37705.\n 5         5   165   0.252 39391.\n 6         6   165   0.224 43224.\n 7         7   164   0.233 42253.\n 8         8   165   0.230 43776.\n 9         9   165   0.215 47064.\n10        10   164   0.209 51795.\n11        NA    12   0.459 32213.\n```\n:::\n:::\n\n:::\n\nCongratulations! You are well on your way to being able to do some very powerful things in R! Take a moment to relish in your accomplishment! \\## Lesson 2 Summary and Debrief\n\nIn this lesson, you ...\n\n## Core Concepts and Terminology\n\n-   R Script\n\n-   Notebook\n\n-   Code Chunk\n\n-   Variables\n\n-   Lists\n\n-   Vectors\n\n-   Data Frame\n",
    "supporting": [
      "rbasics_03_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}